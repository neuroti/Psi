# Psi 프로젝트: PRD, LLD, PLAN 문서

---

# 📋 PART 1: PRD (Product Requirements Document)

## 1.1 개요

**제품명**: Psi (사이)  
**부제**: 감정 기반 웰니스 플랫폼  
**버전**: 1.0.0 (MVP)  
**개발 기간**: 12개월  
**플랫폼**: iOS + Android (React Native)  
**백엔드**: FastAPI (Python)  

---

## 1.2 비즈니스 요구사항

### 1.2.1 문제 정의

**현재 상황**:
- 음식 추천 앱들은 감정을 무시하고 칼로리만 중심
- 웨어러블 데이터(HRV, 심박수)는 대부분 활용 안 됨
- 개인의 감정 상태와 영양 필요가 연계되지 않음
- 신경과학 기반의 감정-영양 매핑이 없음

**해결책**:
Psi는 웨어러블에서 실시간으로 감정을 감지하고, 사용자의 현재 감정 상태에 맞는 음식을 추천합니다.

### 1.2.2 목표 사용자

**Primary Target**:
- 나이: 20-40세
- 직업: 회사원, 학생
- 관심사: 음식, 건강, 웰니스, 심리학
- 기술 수준: 중상급
- 스트레스 수준: 높음

**Secondary Target**:
- 피트니스 관심층
- 정신건강 관심층
- 음식 관심층

### 1.2.3 비즈니스 목표

**Year 1**:
- MAU: 10,000 이상
- 프리미엄 전환율: 15%
- 앱 평점: 4.2/5.0 이상

**Year 3**:
- MAU: 100,000 이상
- 프리미엄 전환율: 35%
- B2B 계약: 10개 이상
- 총 수익: $42.7M

---

## 1.3 기능 요구사항

### 1.3.1 Mode 1: 실시간 감정-영양 분석

**용도**: 음식 사진 업로드 후 감정 기반 분석

**입력**:
- 음식 사진 (JPG, PNG)
- 웨어러블 감정 데이터 (Apple HealthKit / Google Fit)

**출력**:
- 음식 목록 + 신뢰도
- 칼로리 계산 (±50 kcal)
- 영양소 분석 (62개 항목)
- 현재 감정 상태
- 감정-영양 매핑 분석
- 추천사항

**요구사항**:
- FR1.1: 이미지 업로드 가능 (최대 10MB)
- FR1.2: YOLO v8로 음식 인식 (정확도 96%+)
- FR1.3: USDA에서 영양정보 조회 (0.05초 이내)
- FR1.4: 웨어러블 데이터 자동 연동
- FR1.5: 감정-영양 매핑 분석
- FR1.6: 결과 저장 및 히스토리 관리

**성능 요구사항**:
- 음식 인식 정확도: 96%
- API 응답 시간: 2초 이내
- 앱 응답: 1초 이내

---

### 1.3.2 Mode 2: 감정 기반 냉장고 레시피

**용도**: 냉장고 재료로 감정에 맞는 레시피 추천

**입력**:
- 냉장고 사진 5장
- 현재 감정 상태

**출력**:
- 감지된 재료 목록
- 감정별 레시피 (3-5개)
- 조리 시간 + 난이도
- Step-by-step 가이드
- 쇼핑 리스트 (부족한 재료)

**요구사항**:
- FR2.1: 냉장고 사진 5장 업로드
- FR2.2: YOLO v8로 재료 감지 (정확도 95%+)
- FR2.3: TF-IDF로 레시피 매칭
- FR2.4: 감정별 레시피 점수 계산
- FR2.5: 조리 가이드 자동 생성
- FR2.6: 쇼핑 리스트 생성

---

### 1.3.3 Mode 3: 감정 웰니스 허브

**용도**: 실시간 감정 모니터링 및 통합 제안

**입력**:
- 웨어러블 데이터 (실시간)
- 사용자 피드백 (선택)

**출력**:
- 현재 감정 상태 (8가지)
- 일일 웰니스 스코어
- 감정별 추천 (음식, 운동, 콘텐츠)
- 심리학 일일 팁
- 감정 변화 추이

**요구사항**:
- FR3.1: 웨어러블 데이터 10분 주기 동기화
- FR3.2: 8가지 감정 자동 분류
- FR3.3: 웰니스 스코어 계산
- FR3.4: 감정별 추천 생성
- FR3.5: 심리학 콘텐츠 매칭
- FR3.6: 감정 히스토리 시각화

---

### 1.3.4 공통 기능

**계정 관리**:
- FR4.1: 회원가입 (이메일/소셜)
- FR4.2: 로그인 (JWT 토큰)
- FR4.3: 프로필 설정
- FR4.4: 선호도 설정
- FR4.5: 계정 삭제

**웨어러블 연동**:
- FR4.6: Apple HealthKit 연동 (iOS)
- FR4.7: Google Fit 연동 (Android)
- FR4.8: HRV, 심박수 데이터 동기화

**데이터 관리**:
- FR4.9: 음식 기록 저장
- FR4.10: 감정 데이터 저장
- FR4.11: 데이터 내보내기 (CSV)
- FR4.12: 계정 복구

**프리미엄 기능**:
- FR4.13: 무제한 사용 (vs 1일 3회 제한)
- FR4.14: 고급 분석
- FR4.15: 광고 제거
- FR4.16: 전문가 상담 연결

---

## 1.4 비기능 요구사항

### 1.4.1 성능

- NFR1.1: 로딩 시간 < 3초
- NFR1.2: API 응답 < 2초
- NFR1.3: 이미지 처리 < 1초
- NFR1.4: 앱 크기 < 100MB
- NFR1.5: 배터리 소비 < 5% (1시간)

### 1.4.2 보안

- NFR2.1: 데이터 암호화 (TLS 1.3, AES-256)
- NFR2.2: 비밀번호 해싱 (bcrypt)
- NFR2.3: JWT 토큰 (24시간 만료)
- NFR2.4: Rate limiting (100req/min)
- NFR2.5: SQL Injection 방지

### 1.4.3 확장성

- NFR3.1: 10,000 동시 사용자 지원
- NFR3.2: 수평 확장 가능 (Docker)
- NFR3.3: 마이크로서비스 아키텍처
- NFR3.4: 캐싱 레이어 (Redis)

### 1.4.4 가용성

- NFR4.1: 99.5% 가용성
- NFR4.2: 자동 재시작
- NFR4.3: 모니터링 & 알림
- NFR4.4: 로깅 (ELK Stack)

---

## 1.5 데이터 모델

### 1.5.1 주요 엔티티

**User**:
```
user_id (PK)
email
password_hash
profile_pic
created_at
updated_at
```

**FoodRecord**:
```
record_id (PK)
user_id (FK)
image_url
foods (JSON)
total_calories
nutrition (JSON)
emotion_state
created_at
```

**EmotionData**:
```
emotion_id (PK)
user_id (FK)
hrv
heart_rate
coherence
emotion_type
emotion_score
timestamp
```

**Recipe**:
```
recipe_id (PK)
name
ingredients (JSON)
instructions (JSON)
cooking_time
difficulty
emotion_type
created_at
```

---

## 1.6 API 명세

### 1.6.1 Mode 1 API

```
POST /api/v1/food/upload
Request:
  - image: File
  - emotion: {hrv, heart_rate}

Response:
  - food_items: [{name, confidence, grams, calories}]
  - total_calories: float
  - nutrition: {protein, carbs, fat, ...}
  - emotion: {type, score}
  - recommendation: string
  - xp_gained: int
```

### 1.6.2 Mode 2 API

```
POST /api/v1/fridge/detect
Request:
  - images: File[] (5)
  
Response:
  - ingredients: [{name, confidence, quantity}]
  - recipes: [{name, time, difficulty, emotion_score}]
  - shopping_list: [string]
```

### 1.6.3 Mode 3 API

```
GET /api/v1/wellness/check
Response:
  - current_emotion: {type, score, hrv, hr}
  - wellness_score: int
  - recommendations: {food, exercise, content}
  - daily_tip: string
```

---

# 📐 PART 2: LLD (Low-Level Design Document)

## 2.1 아키텍처 개요

### 2.1.1 전체 구조

```
Frontend (React Native)
    ↓ REST API (JSON)
API Gateway (FastAPI)
    ↓
┌─────────────────────────┐
│   Backend Services      │
├─────────────────────────┤
│ - Image Recognition     │
│ - Nutrition Analysis    │
│ - Emotion Analysis      │
│ - Recipe Matching       │
│ - User Management       │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│   Data Layer            │
├─────────────────────────┤
│ - PostgreSQL (ACID)     │
│ - MongoDB (Flexible)    │
│ - Redis (Cache)         │
│ - SQLite (Local USDA)   │
└─────────────────────────┘
```

---

## 2.2 컴포넌트 상세 설계

### 2.2.1 Image Recognition Service

**목표**: 음식 이미지 인식 및 부분 크기 추정

**구현**:
```python
class ImageRecognitionService:
    def __init__(self):
        self.yolo_model = YOLO('yolov8m.pt')
        self.redis_client = redis.Redis()
        self.claude_client = anthropic.Anthropic()
    
    async def analyze_food_image(self, image_bytes: bytes) -> dict:
        """
        1. 이미지 전처리 (640x640)
        2. Redis에서 캐시 확인
        3. YOLO v8 추론 (무료)
        4. 신뢰도 판단
           - > 80%: 반환 (무료)
           - < 80%: Claude 호출 (유료)
        5. 결과 캐싱 (24시간)
        6. 부분 크기 추정 (바운딩 박스)
        """
        pass
    
    def _preprocess_image(self, image_bytes: bytes) -> np.ndarray:
        """이미지 전처리"""
        # 1. 이미지 로드
        image = cv2.imdecode(image_bytes, cv2.IMREAD_COLOR)
        
        # 2. 리사이징 (640x640)
        image = cv2.resize(image, (640, 640))
        
        # 3. 정규화 (0-1)
        image = image / 255.0
        
        return image
    
    async def _run_yolo_inference(self, image: np.ndarray) -> dict:
        """YOLO v8 추론"""
        results = self.yolo_model.predict(image, conf=0.5)
        
        detections = []
        for result in results:
            for box in result.boxes:
                detections.append({
                    'class': box.cls,
                    'confidence': float(box.conf),
                    'bbox': box.xyxy.tolist()
                })
        
        return detections
    
    async def _run_claude_inference(self, image_bytes: bytes) -> dict:
        """Claude Vision 추론 (필요시만)"""
        response = self.claude_client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/jpeg",
                                "data": base64.b64encode(image_bytes).decode()
                            }
                        },
                        {
                            "type": "text",
                            "text": "음식 상세 분석 (이름, 양, 영양소)"
                        }
                    ]
                }
            ]
        )
        return response.content[0].text
```

**성능 목표**:
- 추론 시간: 0.5초 (GPU) / 1-2초 (CPU)
- 정확도: 96%+
- 캐시 히트율: 60%+

---

### 2.2.2 Nutrition Analysis Service

**목표**: 영양정보 조회 및 분석

**구현**:
```python
class NutritionAnalysisService:
    def __init__(self):
        self.db = sqlite3.connect('usda_foods.db')
        self.redis_client = redis.Redis()
    
    async def get_nutrition_info(self, food_name: str) -> dict:
        """
        1. Redis 캐시 확인
        2. 로컬 SQLite 조회
        3. 결과 캐싱 (24시간)
        """
        # 캐시 확인
        cache_key = f"nutrition:{food_name}"
        cached = self.redis_client.get(cache_key)
        if cached:
            return json.loads(cached)
        
        # SQLite 조회
        cursor = self.db.execute(
            "SELECT * FROM foods WHERE name LIKE ?",
            (food_name,)
        )
        result = cursor.fetchone()
        
        if result:
            nutrition = {
                'name': result[0],
                'calories': result[1],
                'protein': result[2],
                'carbs': result[3],
                'fat': result[4],
                # ... 58개 추가 영양소
            }
            
            # 캐싱 (24시간)
            self.redis_client.setex(
                cache_key,
                86400,
                json.dumps(nutrition)
            )
            
            return nutrition
        
        return None
    
    def estimate_portion_size(self, bbox: list, image_size: tuple) -> float:
        """바운딩 박스로 부분 크기 추정"""
        x1, y1, x2, y2 = bbox
        food_pixels = (x2 - x1) * (y2 - y1)
        total_pixels = image_size[0] * image_size[1]
        
        # 휴리스틱: 50% 차지 = 200g
        ratio = food_pixels / total_pixels
        estimated_grams = (ratio / 0.5) * 200
        
        return max(50, min(500, estimated_grams))  # 50-500g
```

**성능 목표**:
- 조회 시간: 0.05초 (로컬)
- 정확도: 98% (공식 데이터)
- 데이터: 400K+ 항목

---

### 2.2.3 Emotion Analysis Service

**목표**: 웨어러블 데이터 분석 및 8가지 감정 분류

**구현**:
```python
class EmotionAnalysisService:
    # 감정 분류 규칙
    EMOTION_RULES = {
        'stress': {
            'hrv': (20, 50),
            'hr': (85, 120),
            'coherence': (0, 0.5)
        },
        'fatigue': {
            'hrv': (20, 40),
            'hr': (50, 70),
            'coherence': (0, 0.3)
        },
        'anxiety': {
            'hrv': 'unstable',  # 변동성 큼
            'hr': (85, 120),
            'coherence': (0, 0.3)
        },
        'happiness': {
            'hrv': (60, 100),
            'hr': (70, 85),
            'coherence': (0.8, 1.0)
        },
        'excitement': {
            'hrv': (40, 60),
            'hr': (90, 110),
            'coherence': (0.6, 0.9)
        },
        'calmness': {
            'hrv': (70, 100),
            'hr': (55, 70),
            'coherence': (0.8, 1.0)
        },
        'focus': {
            'hrv': (50, 70),
            'hr': (80, 95),
            'coherence': (0.9, 1.0)
        },
        'apathy': {
            'hrv': (30, 50),
            'hr': (50, 65),
            'coherence': (0.3, 0.6)
        }
    }
    
    async def classify_emotion(self, hrv: float, hr: float) -> dict:
        """
        1. 웨어러블 데이터 입력
        2. 규칙 기반 분류
        3. 신뢰도 계산
        """
        emotions = []
        
        for emotion_type, rules in self.EMOTION_RULES.items():
            score = self._calculate_emotion_score(hrv, hr, rules)
            emotions.append((emotion_type, score))
        
        # 상위 감정 선택
        top_emotion = sorted(emotions, key=lambda x: x[1], reverse=True)[0]
        
        return {
            'type': top_emotion[0],
            'score': int(top_emotion[1]),
            'all_emotions': dict(emotions)
        }
    
    def _calculate_emotion_score(self, hrv: float, hr: float, rules: dict) -> float:
        """감정 점수 계산 (0-100)"""
        score = 0
        
        # HRV 계산
        if isinstance(rules['hrv'], tuple):
            hrv_min, hrv_max = rules['hrv']
            if hrv_min <= hrv <= hrv_max:
                score += 40
            else:
                score += max(0, 40 - abs(hrv - hrv_min))
        
        # HR 계산
        if isinstance(rules['hr'], tuple):
            hr_min, hr_max = rules['hr']
            if hr_min <= hr <= hr_max:
                score += 40
            else:
                score += max(0, 40 - abs(hr - hr_min))
        
        # 기타
        score += 20
        
        return min(100, score)
```

**성능 목표**:
- 분류 시간: 100ms
- 정확도: 75-80%
- 업데이트 주기: 10분

---

### 2.2.4 Recipe Matching Service

**목표**: TF-IDF로 레시피 매칭

**구현**:
```python
class RecipeMatchingService:
    def __init__(self):
        self.recipe_db = []
        self.vectorizer = TfidfVectorizer()
        self._load_recipes()
    
    async def match_recipes(
        self,
        ingredients: list,
        emotion_type: str
    ) -> list:
        """
        1. 재료 기반 TF-IDF 검색
        2. 사용 가능 재료 70% 이상만
        3. 감정별 점수 계산
        4. 상위 5개 반환
        """
        # 재료 벡터화
        ingredient_text = ' '.join(ingredients)
        
        # TF-IDF 검색
        candidates = self._search_recipes(ingredient_text)
        
        # 감정 점수 추가
        for recipe in candidates:
            recipe['emotion_score'] = self._score_by_emotion(
                recipe,
                emotion_type
            )
        
        # 정렬 및 반환
        return sorted(
            candidates,
            key=lambda x: x['emotion_score'],
            reverse=True
        )[:5]
    
    def _score_by_emotion(self, recipe: dict, emotion_type: str) -> float:
        """감정별 레시피 점수"""
        base_score = 0.5
        
        emotion_preferences = {
            'stress': {'cooking_time': (5, 10), 'difficulty': 'easy'},
            'fatigue': {'ingredients': 'high_nutrition', 'cooking_time': (10, 15)},
            'happiness': {'difficulty': 'medium', 'presentation': 'fancy'},
            # ... 기타 감정
        }
        
        prefs = emotion_preferences.get(emotion_type, {})
        
        # 조리 시간 점수
        if 'cooking_time' in prefs:
            target_min, target_max = prefs['cooking_time']
            actual = recipe.get('cooking_time', 15)
            time_score = 1 - abs(actual - (target_min + target_max) / 2) / 30
            base_score += time_score * 0.25
        
        # 난이도 점수
        if 'difficulty' in prefs:
            base_score += (recipe.get('difficulty') == prefs['difficulty']) * 0.25
        
        return min(1.0, base_score)
```

---

### 2.2.5 User Management Service

**목표**: 회원 인증, 프로필 관리

**구현**:
```python
class UserManagementService:
    async def register_user(self, email: str, password: str) -> dict:
        """회원가입"""
        # 중복 확인
        existing = await db.users.find_one({'email': email})
        if existing:
            raise ValueError("Email already exists")
        
        # 암호 해싱
        password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
        
        # 사용자 생성
        user = {
            'email': email,
            'password_hash': password_hash,
            'created_at': datetime.now(),
            'updated_at': datetime.now(),
            'preferences': {}
        }
        
        result = await db.users.insert_one(user)
        return {'user_id': str(result.inserted_id)}
    
    async def login_user(self, email: str, password: str) -> dict:
        """로그인"""
        user = await db.users.find_one({'email': email})
        
        if not user or not bcrypt.checkpw(password.encode(), user['password_hash']):
            raise ValueError("Invalid email or password")
        
        # JWT 토큰 생성
        token = jwt.encode(
            {
                'user_id': str(user['_id']),
                'exp': datetime.utcnow() + timedelta(hours=24)
            },
            os.getenv('JWT_SECRET'),
            algorithm='HS256'
        )
        
        return {'token': token}
```

---

## 2.3 데이터베이스 설계

### 2.3.1 PostgreSQL (ACID)

```sql
-- Users 테이블
CREATE TABLE users (
    user_id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    profile_pic_url VARCHAR(500),
    subscription_type ENUM('free', 'premium'),
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

-- Food Records 테이블
CREATE TABLE food_records (
    record_id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(user_id),
    image_url VARCHAR(500),
    foods JSONB,
    total_calories DECIMAL(10, 2),
    nutrition JSONB,
    emotion_state VARCHAR(50),
    emotion_score INTEGER,
    created_at TIMESTAMP
);

-- Emotion Data 테이블
CREATE TABLE emotion_data (
    emotion_id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(user_id),
    hrv DECIMAL(10, 2),
    heart_rate INTEGER,
    coherence DECIMAL(3, 2),
    emotion_type VARCHAR(50),
    emotion_score INTEGER,
    timestamp TIMESTAMP
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_food_records_user ON food_records(user_id);
CREATE INDEX idx_emotion_data_user_time ON emotion_data(user_id, timestamp);
```

### 2.3.2 MongoDB (Flexible)

```javascript
// User Preferences
db.user_preferences.insert({
    _id: ObjectId(),
    user_id: "uuid",
    liked_foods: [array],
    disliked_foods: [array],
    dietary_restrictions: [array],
    notification_enabled: true
});

// Emotion Time Series
db.emotion_timeseries.insert({
    _id: ObjectId(),
    user_id: "uuid",
    date: ISODate(),
    hourly_emotions: [
        {hour: 0, emotion: "sleep"},
        {hour: 1, emotion: "sleep"},
        // ...
    ]
});

// RLHF Training Data
db.rlhf_training_data.insert({
    _id: ObjectId(),
    user_id: "uuid",
    prompt: "recommendation",
    chosen_response: "response_a",
    rejected_response: "response_b",
    timestamp: ISODate()
});

// Indexes
db.user_preferences.createIndex({user_id: 1});
db.emotion_timeseries.createIndex({user_id: 1, date: -1});
```

---

## 2.4 API 게이트웨이 설계

```python
from fastapi import FastAPI, HTTPException, Depends
from fastapi.security import HTTPBearer, HTTPAuthCredentials
import jwt

app = FastAPI(title="Psi API", version="1.0.0")
security = HTTPBearer()

async def verify_token(credentials: HTTPAuthCredentials = Depends(security)) -> str:
    """토큰 검증"""
    try:
        payload = jwt.decode(
            credentials.credentials,
            os.getenv('JWT_SECRET'),
            algorithms=['HS256']
        )
        return payload['user_id']
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

# Mode 1: 음식 분석
@app.post("/api/v1/food/upload")
async def upload_food(
    file: UploadFile = File(...),
    user_id: str = Depends(verify_token)
) -> dict:
    """음식 사진 분석"""
    image_service = ImageRecognitionService()
    nutrition_service = NutritionAnalysisService()
    emotion_service = EmotionAnalysisService()
    
    # 1. 이미지 처리
    image_bytes = await file.read()
    foods = await image_service.analyze_food_image(image_bytes)
    
    # 2. 웨어러블 데이터 조회
    wearable_data = await get_wearable_data(user_id)
    emotion = await emotion_service.classify_emotion(
        wearable_data['hrv'],
        wearable_data['hr']
    )
    
    # 3. 영양 분석
    total_calories = 0
    nutrition_breakdown = []
    
    for food in foods:
        nutrition = await nutrition_service.get_nutrition_info(food['name'])
        grams = nutrition_service.estimate_portion_size(food['bbox'])
        
        food_calories = (nutrition['calories'] / 100) * grams
        total_calories += food_calories
        
        nutrition_breakdown.append({
            'name': food['name'],
            'grams': grams,
            'calories': food_calories
        })
    
    # 4. 감정-영양 분석
    recommendation = await emotion_nutrition_mapping(emotion, nutrition)
    
    # 5. 결과 저장
    record = {
        'user_id': user_id,
        'foods': nutrition_breakdown,
        'total_calories': total_calories,
        'emotion': emotion,
        'recommendation': recommendation,
        'created_at': datetime.now()
    }
    
    await db.food_records.insert_one(record)
    
    return {
        'foods': nutrition_breakdown,
        'total_calories': round(total_calories, 1),
        'emotion': emotion,
        'recommendation': recommendation,
        'xp_gained': 15
    }

# Mode 2: 냉장고 레시피
@app.post("/api/v1/fridge/detect")
async def detect_fridge(
    files: list[UploadFile] = File(...),
    user_id: str = Depends(verify_token)
) -> dict:
    """냉장고 재료 감지 및 레시피 추천"""
    # 구현...
    pass

# Mode 3: 웰니스
@app.get("/api/v1/wellness/check")
async def wellness_check(
    user_id: str = Depends(verify_token)
) -> dict:
    """웰니스 상태 확인"""
    # 구현...
    pass
```

---

## 2.5 외부 API 통합

### 2.5.1 YOLO v8 통합

```python
from ultralytics import YOLO
import torch

class YOLOIntegration:
    def __init__(self):
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.model = YOLO('models/psi_food_best.pt')  # 미세조정 모델
    
    async def predict(self, image: np.ndarray) -> list:
        """YOLO v8 추론"""
        results = self.model.predict(
            source=image,
            conf=0.5,
            device=self.device,
            verbose=False
        )
        
        detections = []
        for result in results:
            for box in result.boxes:
                detections.append({
                    'class': result.names[int(box.cls)],
                    'confidence': float(box.conf),
                    'bbox': box.xyxy.tolist()
                })
        
        return detections
```

### 2.5.2 Claude Vision 통합

```python
import anthropic
import base64

class ClaudeVisionIntegration:
    def __init__(self):
        self.client = anthropic.Anthropic(api_key=os.getenv('CLAUDE_API_KEY'))
    
    async def analyze_image(self, image_bytes: bytes) -> str:
        """Claude Vision으로 상세 분석"""
        response = self.client.messages.create(
            model="claude-3-5-sonnet-20241022",
            max_tokens=1024,
            messages=[
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image",
                            "source": {
                                "type": "base64",
                                "media_type": "image/jpeg",
                                "data": base64.b64encode(image_bytes).decode()
                            }
                        },
                        {
                            "type": "text",
                            "text": """
                            음식을 상세히 분석해주세요:
                            1. 음식명 (정확한 이름)
                            2. 추정 무게 (그램)
                            3. 주요 영양소
                            4. 조리 방법 (예상)
                            
                            JSON 형식으로 응답:
                            {
                                "food_name": "...",
                                "estimated_weight": ...,
                                "nutrients": {...},
                                "cooking_method": "..."
                            }
                            """
                        }
                    ]
                }
            ]
        )
        
        return response.content[0].text
```

### 2.5.3 Apple HealthKit 통합 (React Native)

```javascript
import { NativeModules } from 'react-native';
import AppleHealthKit from 'rn-apple-healthkit';

const HealthKitIntegration = {
    async requestPermissions() {
        const options = {
            permissions: {
                read: [AppleHealthKit.Constants.Permissions.HKCategoryTypeIdentifierMindfulSession],
                write: [AppleHealthKit.Constants.Permissions.HKCategoryTypeIdentifierMindfulSession]
            }
        };
        
        return new Promise((resolve, reject) => {
            AppleHealthKit.initHealthKit(options, (err, result) => {
                if (err) reject(err);
                else resolve(result);
            });
        });
    },
    
    async getHeartRateVariability() {
        return new Promise((resolve, reject) => {
            AppleHealthKit.getHeartRateVariabilitySamples({
                startDate: new Date(Date.now() - 24 * 60 * 60 * 1000),
                endDate: new Date(),
                limit: 1
            }, (err, results) => {
                if (err) reject(err);
                else resolve(results);
            });
        });
    }
};
```

---

# 📅 PART 3: PLAN (전체 계획)

## 3.1 개발 타임라인

### Phase 1: Foundation (Month 1-3)

#### Week 1-2: 개발 환경 & 기초 설정
```
Task 1: 개발 환경 구성
├─ PyCharm Pro 설정
├─ GitHub Copilot 활성화
├─ Poetry로 의존성 관리
├─ Docker 설정 (PostgreSQL, MongoDB, Redis)
└─ 로컬 개발 환경 테스트

Task 2: 프로젝트 구조
├─ FastAPI 프로젝트 초기화
├─ React Native 프로젝트 초기화
├─ Git workflow 설정 (main, develop, feature)
└─ CI/CD 파이프라인 (GitHub Actions)

Task 3: 데이터베이스 설계
├─ PostgreSQL 스키마 설계
├─ MongoDB 컬렉션 설계
├─ SQLite USDA DB 구축
└─ 인덱스 최적화

시간: 40시간
담당: 1인
```

#### Week 3-4: Mode 1 음식 인식
```
Task 4: YOLO v8 통합
├─ YOLO v8 모델 다운로드
├─ 기본 추론 파이프라인 구현
├─ 이미지 전처리 함수 작성
├─ 캐싱 레이어 (Redis) 추가
└─ 단위 테스트 작성

Task 5: 영양 정보 API
├─ USDA SQLite DB 로드
├─ 영양 조회 함수 구현
├─ 부분 크기 추정 알고리즘
├─ 칼로리 계산 엔진
└─ 테스트 (정확도 98%+)

Task 6: FastAPI 엔드포인트
├─ POST /api/v1/food/upload 구현
├─ 입력 검증 로직
├─ 에러 처리
├─ 응답 형식 정의
└─ API 문서화 (Swagger)

Task 7: 감정 데이터 통합
├─ 웨어러블 데이터 포맷 정의
├─ 감정-영양 매핑 로직
├─ 추천 시스템 기본 구현
└─ 테스트

시간: 60시간
담당: 1인
```

#### Week 5-6: Mode 2 냉장고 레시피
```
Task 8: YOLO 냉장고 감지
├─ 냉장고 재료 감지 모델
├─ 다중 이미지 처리
├─ 재료 목록 통합
└─ 테스트

Task 9: 레시피 매칭
├─ 레시피 DB 구축 (500개)
├─ TF-IDF 벡터화
├─ 매칭 알고리즘 구현
├─ 감정별 점수 계산
└─ 테스트

Task 10: FastAPI 엔드포인트
├─ POST /api/v1/fridge/detect 구현
├─ 쇼핑 리스트 생성
├─ 조리 가이드 자동 생성
└─ 테스트

시간: 50시간
담당: 1인
```

#### Week 7-8: Mode 3 웰니스 허브
```
Task 11: 감정 분류 모델
├─ 8가지 감정 분류 규칙 정의
├─ HRV + HR 기반 분류
├─ 신뢰도 계산
└─ 테스트 (정확도 75%+)

Task 12: 웰니스 대시보드
├─ 실시간 감정 모니터링
├─ 일일 스코어 계산
├─ 추천 생성 로직
├─ 히스토리 시각화
└─ 테스트

Task 13: FastAPI 엔드포인트
├─ GET /api/v1/wellness/check 구현
├─ 실시간 데이터 반환
└─ 테스트

시간: 40시간
담당: 1인
```

#### Week 9-10: React Native 프론트엔드
```
Task 14: UI/UX 구현
├─ Mode 1 화면 구현
├─ Mode 2 화면 구현
├─ Mode 3 화면 구현
├─ 네비게이션 구현
└─ 스타일링

Task 15: API 연동
├─ API 클라이언트 구현 (axios)
├─ 상태 관리 (Redux)
├─ 에러 처리
└─ 로딩 상태 관리

Task 16: 웨어러블 통합
├─ Apple HealthKit 권한 요청
├─ HRV 데이터 수집
├─ 심박수 데이터 수집
├─ 권한 없음 시 처리
└─ 테스트 (iOS)

시간: 80시간
담당: 1인 (또는 2인)
```

#### Week 11-12: 통합 & 테스트
```
Task 17: 3개 Mode 통합 테스트
├─ End-to-End 테스트
├─ 성능 테스트
├─ 보안 테스트
└─ 사용성 테스트

Task 18: 베타 테스트
├─ Expo Go로 배포
├─ 테스터 10명 모집
├─ 피드백 수집
├─ 버그 수정

Task 19: 배포 준비
├─ 앱 아이콘 준비
├─ 스크린샷 촬영
├─ 메타데이터 작성
└─ 개인정보처리방침 작성

시간: 60시간
담당: 1인
```

**Phase 1 총 시간: 370시간 (약 3개월, 1인 기준)**

---

### Phase 2: Integration & Beta (Month 4-9)

#### YOLO v8 미세조정 (Month 4-6)

```
Task 20: 학습 데이터 수집
├─ AI Hub 한국 음식 다운로드 (10,000장)
├─ Roboflow 추가 데이터 (670장)
├─ 자체 촬영 (200장)
└─ 데이터 정제 및 분류

Task 21: 데이터 라벨링
├─ Roboflow Annotate 사용 (무료 100개)
├─ LabelImg로 추가 라벨링
├─ YOLO 포맷 변환
└─ 학습/검증 분할 (80/20)

Task 22: YOLO 미세조정
├─ Transfer Learning (freeze=10)
├─ 100 epoch 학습
├─ 데이터 증강 (mosaic, rotation)
├─ 모델 평가 (정확도 96%+)
└─ 모델 저장 및 배포

시간: 60시간
담당: 1인
```

#### 베타 테스트 (Month 7-9)

```
Task 23: TestFlight/Google Play Beta 배포
├─ Expo 베타 채널 생성
├─ EAS Build 설정
├─ TestFlight 제출
├─ Google Play Beta 제출
└─ 배포 모니터링

Task 24: 사용자 피드백 수집
├─ 50명 베타 테스터 모집
├─ 피드백 수집 (설문조사)
├─ 크래시 리포트 분석
├─ 성능 메트릭 분석
└─ 우선순위 결정

Task 25: 개선 및 최적화
├─ UI/UX 개선
├─ 성능 최적화
├─ 버그 수정
├─ 정확도 개선
└─ 최종 테스트

시간: 100시간
담당: 1인 + 피드백팀
```

**Phase 2 총 시간: 160시간**

---

### Phase 3: Launch (Month 10-12)

#### 정식 출시 (Month 10-12)

```
Task 26: 정식 빌드 생성
├─ EAS Build 최종 설정
├─ 버전 업데이트 (1.0.0)
├─ 빌드 생성 (iOS + Android)
├─ 서명 및 검증
└─ 배포 준비

Task 27: App Store 출시
├─ 메타데이터 최종 검토
├─ 스크린샷 최적화
├─ 설명문 다국어화
├─ EAS Submit으로 자동 제출
├─ Apple 심사 대기 (1-3일)
└─ 승인 후 배포

Task 28: Google Play 출시
├─ 메타데이터 최종 검토
├─ Google Play 제출
├─ Google 자동 심사 (2-3시간)
├─ 승인 후 배포
└─ 모니터링

Task 29: Series A 준비
├─ 피치덱 작성
├─ 파이낸셜 모델 작성
├─ 투자자 미팅 준비
├─ 기술 문서 정리
└─ 팀 구성 계획

시간: 80시간
담당: 1인 + 비즈니스팀
```

**Phase 3 총 시간: 80시간**

---

## 3.2 리소스 계획

### 팀 구성

**Phase 1 (1인 개발)**:
- 1명: Full-stack 개발자 (당신)

**Phase 2 (선택 사항)**:
- 1명: 디자이너 (UI/UX 개선)
- 1명: QA 엔지니어 (테스트)

**Phase 3+ (팀 확대)**:
- 1명: 마케팅
- 1명: 비즈니스
- 2명: 백엔드 개발자
- 1명: 모바일 개발자
- 1명: DevOps

---

## 3.3 위험 관리

| 위험 | 심각도 | 대처 방안 |
|------|--------|----------|
| YOLO 정확도 < 90% | 높음 | 미세조정 데이터 증가 (1,000 → 2,000장) |
| Apple 심사 거절 | 중간 | 의료 주장 피하기, 명확한 설명 |
| 웨어러블 연동 실패 | 중간 | 수동 입력 옵션 제공 |
| 사용자 확보 실패 | 높음 | 온라인 커뮤니티 마케팅 강화 |
| 클라우드 비용 증가 | 낮음 | 자체 서버 이관 계획 |

---

## 3.4 성공 지표

### 기술 지표
- ✅ YOLO 정확도: 96%+
- ✅ API 응답 시간: 2초 이내
- ✅ 앱 시작 시간: 3초 이내
- ✅ 크래시율: < 1%

### 비즈니스 지표
- ✅ MAU: 10,000+ (Month 12)
- ✅ 프리미엄 전환율: 15%+
- ✅ 앱 평점: 4.2/5.0 이상
- ✅ Series A 자금 조달

---

## 3.5 다음 단계

### 이번 주 (Week 1)
- [ ] PyCharm Pro 학생 라이선스 신청
- [ ] GitHub Student Pack 신청
- [ ] GitHub 레포지토리 생성
- [ ] Claude CLI 설정

### 1개월 내 (Month 1)
- [ ] FastAPI 프로젝트 구조 완성
- [ ] YOLO v8 기본 통합 완료
- [ ] USDA DB 구축 완료
- [ ] 첫 번째 API 엔드포인트 완성

### 3개월 내 (Month 3)
- [ ] MVP 완성
- [ ] Expo Go 배포
- [ ] 베타 테스터 10명
- [ ] 정확도 90%+ 달성

---

# 🎯 최종 체크리스트

## Claude CLI 사용 시작

```bash
# 1. Claude CLI 설치
npm install -g @anthropic-ai/claude-cli

# 2. API 키 설정
export ANTHROPIC_API_KEY="your-api-key"

# 3. 프로젝트 구조 요청
claude project-structure --framework fastapi --template full-stack

# 4. 구현 요청
claude implement --file /path/to/requirements.md

# 5. 코드 리뷰
claude review --file /path/to/code.py

# 6. 테스트 생성
claude generate-tests --file /path/to/code.py

# 7. 문서 생성
claude generate-docs --project psi
```

---

**이제 Claude CLI와 함께 개발을 시작하세요! 🚀**